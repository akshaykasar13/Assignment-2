name: CI (Self-Hosted -> Dashboard)

on:
  push:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      force_fail:
        description: 'Force the job to fail (true/false)'
        type: choice
        options: [ "true", "false" ]
        default: "true"

permissions:
  contents: read

env:
  PIPELINE_NAME: ${{ github.workflow }}
  BRANCH: ${{ github.ref_name }}
  COMMIT: ${{ github.sha }}
  ACTOR: ${{ github.actor }}

jobs:
  build:
    # Use your Windows self-hosted runner labels.
    runs-on: [self-hosted, Windows]

    defaults:
      run:
        shell: powershell  # Use Windows PowerShell (pwsh not required)

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Mark start time
        run: |
          $ts = [int]([DateTimeOffset]::UtcNow.ToUnixTimeSeconds())
          "START_TS=$ts" | Out-File -FilePath $env:GITHUB_ENV -Append

      - name: Probe dashboard health
        env:
          DASHBOARD_URL: ${{ secrets.DASHBOARD_URL }}
        run: |
          if (-not $env:DASHBOARD_URL) {
            Write-Error "DASHBOARD_URL secret not set. For self-hosted on same box use: http://localhost:8000"
            exit 1
          }
          Write-Host "Probing $env:DASHBOARD_URL/health"
          try {
            $r = Invoke-RestMethod -Method Get -Uri "$env:DASHBOARD_URL/health"
            Write-Host "Health OK:" ($r | ConvertTo-Json -Depth 4)
          } catch {
            Write-Error "Cannot reach dashboard health endpoint."
            throw
          }

      - name: Do some work
        run: |
          Write-Host "Running a trivial step..."
          Start-Sleep -Seconds 3

      - name: Fail intentionally (for testing)
        if: ${{ github.event.inputs.force_fail == 'true' }}
        run: exit 1

      - name: Notify dashboard (always)
        if: ${{ always() }}
        env:
          DASHBOARD_URL: ${{ secrets.DASHBOARD_URL }}
          JOB_STATUS: ${{ job.status }}
        run: |
          $end = [int]([DateTimeOffset]::UtcNow.ToUnixTimeSeconds())
          $dur = $end - [int]$env:START_TS
          $startIso  = [DateTimeOffset]::FromUnixTimeSeconds([int]$env:START_TS).UtcDateTime.ToString("o")
          $finishIso = [DateTimeOffset]::FromUnixTimeSeconds($end).UtcDateTime.ToString("o")
          $status = if ($env:JOB_STATUS -eq "success") { "success" } else { "failure" }

          $body = @{
            pipeline     = "${{ github.workflow }}"
            status       = $status
            duration_sec = $dur
            started_at   = $startIso
            finished_at  = $finishIso
            branch       = "${{ github.ref_name }}"
            commit       = "${{ github.sha }}"
            triggered_by = "${{ github.actor }}"
          } | ConvertTo-Json -Depth 10

          Write-Host "POST -> $env:DASHBOARD_URL/api/events/run"
          Write-Host $body

          try {
            # Use Invoke-WebRequest so we can read error bodies too
            $resp = Invoke-WebRequest -UseBasicParsing -Method Post `
              -Uri "$env:DASHBOARD_URL/api/events/run" `
              -ContentType "application/json" `
              -Body $body
            Write-Host "Ingest OK (status $($resp.StatusCode))"
            Write-Host $resp.Content
          } catch {
            Write-Warning "Ingest FAILED"
            if ($_.Exception.Response) {
              $status = $_.Exception.Response.StatusCode.value__
              $stream = $_.Exception.Response.GetResponseStream()
              if ($stream) {
                $reader = New-Object IO.StreamReader($stream)
                $text = $reader.ReadToEnd()
                Write-Host "StatusCode: $status"
                Write-Host "Error body:"
                Write-Host $text
              }
            }
            throw
          }
